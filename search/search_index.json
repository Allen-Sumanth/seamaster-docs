{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to SeaWars!","text":"<p>Seawars is a competitive programming game where you write code to control bots in a real-time strategic battle. Your goal is to harvest algae, manage your economy, and outsmart your opponent's algorithm.</p> <p>Work in Progress</p> <p>The <code>Lurker</code> and <code>Saboteur</code> templates are currently under development and are not stable for use.</p>"},{"location":"#the-objective","title":"The Objective","text":"<p>You are the commander of a fleet of automated bots. Your mission is to dominate the ocean grid by:</p> <ol> <li>Harvesting Algae: Collecting resources to build your economy.</li> <li>Banking Resources: Securely depositing algae to score permanent points.</li> <li>Combat: Destroying enemy bots to deny them resources.</li> </ol> <p>The winner is determined after 500 ticks (turns) based on who has collected the most algae, or immediately if a player captures (harvests and succefully deposits in their own banks) &gt;50% of the total algae on the map. See Win Conditions for more details.</p>"},{"location":"#how-it-works","title":"How It Works","text":"<p>Seawars is a 1v1 turn-based game.</p> <ul> <li>You write code: You submit a Python script containing a bot controller class. This code defines your strategy for the entire match and cannot be changed once the game begins. Your bot's logic must autonomously guide its actions across all 500 ticks of the game.</li> <li>The Engine runs the match: Your code is executed every tick alongside your opponent's code.</li> <li>Real-time Logic: You must make decisions about movement, spawning, and combat within strict time limits.</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<ol> <li>Read about The Board and Game Entities to understand the environment.</li> <li>Learn the Rules of Perception and Actions.</li> <li>Jump into the SDK Guide to write your first bot.</li> </ol>"},{"location":"api_reference/bot_context/","title":"BotContext (<code>self.ctx</code>)","text":"<p>Accessible inside <code>act()</code> via <code>self.ctx</code>. Provides a read-only interface to the game state for a specific bot.</p>"},{"location":"api_reference/bot_context/#robot-status","title":"Robot Status","text":"<ul> <li><code>get_id()</code>: Returns the unique bot ID (int).</li> <li><code>get_energy()</code>: Returns current energy (int).</li> <li><code>get_location()</code>: Returns current <code>Point</code> (x, y).</li> <li><code>get_abilities()</code>: Returns list of abilities (<code>list[str]</code>).</li> <li><code>get_algae_held()</code>: Returns amount of algae held (int).</li> <li><code>get_type()</code>: Returns list of abilities (alias for <code>get_abilities</code>).</li> <li><code>spawn_cost(abilities)</code>: Returns the scrap cost to spawn a bot with given abilities (int).</li> <li><code>api</code>: The <code>GameAPI</code> instance (see GameAPI).</li> </ul>"},{"location":"api_reference/bot_context/#example","title":"Example","text":"<pre><code># Check energy and location\nif self.ctx.get_energy() &lt; 10:\n    print(f\"Bot {self.ctx.get_id()} is low on energy at {self.ctx.get_location()}\")\n</code></pre>"},{"location":"api_reference/bot_context/#sensing","title":"Sensing","text":"<ul> <li><code>sense_enemies()</code>: Returns list of visible <code>EnemyBot</code>s.</li> <li><code>sense_enemies_in_radius(point, radius)</code>: Returns list of <code>EnemyBot</code>s within radius of a point.</li> <li><code>sense_own_bots()</code>: Returns list of your other <code>Bot</code>s.</li> <li><code>sense_own_bots_in_radius(point, radius)</code>: Returns list of your <code>Bot</code>s within radius of a point.</li> <li><code>sense_algae(radius)</code>: Returns list of <code>Algae</code> within radius of the bot.</li> <li><code>sense_algae_in_radius(point, radius)</code>: Returns list of <code>Algae</code> within radius of a point.</li> <li><code>sense_unknown_algae(point)</code>: Returns sorted list of <code>(distance, Algae)</code> tuples for algae with unknown poison status.</li> <li><code>sense_scraps_in_radius(point, radius)</code>: Returns list of <code>Scrap</code> within radius of a point.</li> <li><code>sense_objects()</code>: Returns a dict containing lists of <code>scraps</code>, <code>banks</code>, and <code>energypads</code>.</li> <li><code>sense_walls()</code>: Returns list of all visible walls (<code>list[Point]</code>).</li> <li><code>sense_walls_in_radius(point, radius)</code>: Returns list of walls within radius of a point.</li> </ul>"},{"location":"api_reference/bot_context/#example_1","title":"Example","text":"<pre><code># Find enemies nearby\nenemies = self.ctx.sense_enemies_in_radius(self.ctx.get_location(), 2)\nif enemies:\n    # React to enemy\n    pass\n</code></pre>"},{"location":"api_reference/bot_context/#pathing-checks","title":"Pathing &amp; Checks","text":"<ul> <li><code>next_point(pos, direction)</code>: Returns the next <code>Point</code> in direction, or <code>None</code> if out of bounds.</li> <li><code>next_point_speed(pos, direction, step)</code>: Returns next <code>Point</code> for speed move (step 1 or 2), or <code>None</code> if invalid.</li> <li><code>run_bfs(start, end)</code>: Returns a list of points representing the shortest path, or empty list if no path.</li> <li><code>can_move(direction)</code>: Returns <code>True</code> if moving in detail direction is within map bounds.</li> <li><code>shortest_path(target)</code>: Returns Manhattan distance to target (int).</li> <li><code>check_blocked_point(point)</code>: Returns <code>True</code> if point is blocked by wall, enemy, or own bot.</li> <li><code>check_blocked_direction(direction)</code>: Returns <code>True</code> if moving in direction would result in a blocked position.</li> <li><code>can_defend()</code>: Returns <code>True</code> if bot has <code>SHIELD</code> ability.</li> <li><code>can_spawn(abilities)</code>: Returns <code>True</code> if you have enough scraps and bot limit is not reached.</li> </ul>"},{"location":"api_reference/bot_context/#example_2","title":"Example","text":"<pre><code>from seamaster.constants import Direction\n\n# Check if moving North is possible\nif self.ctx.can_move(Direction.NORTH):\n    # Check if blocked by obstacle\n    if not self.ctx.check_blocked_direction(Direction.NORTH):\n        return move(Direction.NORTH)\n</code></pre>"},{"location":"api_reference/bot_context/#nearest-object-helpers","title":"Nearest Object Helpers","text":"<ul> <li><code>get_nearest_bank()</code>: Returns the nearest <code>Bank</code>.</li> <li><code>get_energy_pads()</code>: Returns list of all <code>EnergyPad</code>s.</li> <li><code>get_nearest_energy_pad()</code>: Returns the nearest <code>EnergyPad</code>.</li> <li><code>get_nearest_scrap()</code>: Returns the nearest <code>Scrap</code>.</li> <li><code>get_nearest_algae()</code>: Returns the nearest <code>Algae</code>.</li> <li><code>get_nearest_enemy()</code>: Returns the nearest enemy <code>Bot</code>.</li> </ul>"},{"location":"api_reference/bot_context/#example_3","title":"Example","text":"<pre><code>from seamaster.entities import EnergyPad\nfrom seamaster.models.energy_pad import EnergyPad\n\n# Go to nearest energy pad\npad: EnergyPad = self.ctx.get_nearest_energy_pad()\nif pad:\n     # Move towards pad...\n     pass\n</code></pre>"},{"location":"api_reference/bot_context/#collision-avoidance","title":"Collision Avoidance","text":"<ul> <li><code>move_target(bot_pos, target_pos)</code>: Returns the best <code>Direction</code> to move towards target, avoiding obstacles. Returns <code>None</code> if no path.</li> <li><code>move_target_speed(bot_pos, target_pos)</code>: Returns a tuple <code>(Direction, steps)</code> for speed-boosted movement. <code>steps</code> is 1 or 2.</li> </ul>"},{"location":"api_reference/bot_context/#example_4","title":"Example","text":"<pre><code># Safe movement towards target\ndirection = self.ctx.move_target(self.ctx.get_location(), target_point)\nif direction:\n    return move(direction)\n</code></pre>"},{"location":"api_reference/bot_controller/","title":"BotController","text":"<p>Base class for all bot strategies. accessible in <code>agent/src/seamaster/bot_controller.py</code>.</p> <p>To create a new bot strategy, you must inherit from <code>BotController</code> and implement the <code>act</code> method. The <code>act</code> method is called every tick and must return an <code>Action</code> or <code>None</code>.</p> <p>You can access the <code>BotContext</code> via <code>self.ctx</code> to interact with the game state.</p>"},{"location":"api_reference/bot_controller/#example","title":"Example","text":"<pre><code>from seamaster.botbase import BotController\nfrom seamaster.constants import Ability\nfrom seamaster.translate import Action\n\nclass MyBot(BotController):\n    # Define abilities to equip\n    ABILITIES = [Ability.SPEED_BOOST]\n\n    def __init__(self, ctx, args=None):\n        super().__init__(ctx, args)\n        # Custom initialization\n\n    def act(self) -&gt; Action | None:\n        # Main logic loop\n        return None \n</code></pre>"},{"location":"api_reference/bot_controller/#methods","title":"Methods","text":"<ul> <li><code>act()</code>: Abstract method. Must be implemented by the subclass. Returns <code>Action</code> or <code>None</code>.</li> <li><code>spawn(location, args)</code>: Class method to create a spawn specification.</li> </ul>"},{"location":"api_reference/bot_controller/#actions-seamastertranslate","title":"Actions (<code>seamaster.translate</code>)","text":"<p>To perform an action, your <code>act</code> method must return an <code>Action</code> object. These helper functions in <code>seamaster.translate</code> create the appropriate <code>Action</code> for you.</p> <ul> <li><code>move(direction)</code>: Moves the bot in the given direction.</li> <li><code>move_speed(direction)</code>: Moves the bot 2 steps in the given direction (requires <code>SPEED_BOOST</code> ability).</li> <li><code>harvest(direction)</code>: Harvests algae in the given direction.</li> <li><code>deposit(direction)</code>: Deposits resources into a bank or energy pad in the given direction.</li> <li><code>self_destruct()</code>: Destroys the bot and deals damage to surrounding units.</li> </ul>"},{"location":"api_reference/bot_controller/#example-action-logic","title":"Example Action Logic","text":"<p>Here is an example of how to use these actions in your bot's logic:</p> <pre><code>from seamaster.botbase import BotController\nfrom seamaster.translate import move, harvest, deposit\nfrom seamaster import utils\n\nclass harvester_bot(BotController):\n    def act(self):\n        # 1. Deposit Algae if holding any\n        if self.ctx.get_algae_held() &gt; 0:\n            nearest_bank = self.ctx.get_nearest_bank()\n            if nearest_bank:\n                dist = utils.manhattan_distance(self.ctx.get_location(), nearest_bank.location)\n\n                # If adjacent, deposit\n                if dist &lt; 2:\n                    return deposit(utils.direction_from_point(self.ctx.get_location(), nearest_bank.location))\n\n                # Otherwise move towards bank\n                hops = utils.get_optimal_next_hops(self.ctx.get_location(), nearest_bank.location)\n                if hops:\n                    return move(hops[0])\n\n        # 2. Harvest Algae\n        nearest_algae = self.ctx.get_nearest_algae()\n        if nearest_algae:\n            dist = utils.manhattan_distance(self.ctx.get_location(), nearest_algae.location)\n\n            # If adjacent, harvest\n            if dist &lt; 2:\n                return harvest(utils.direction_from_point(self.ctx.get_location(), nearest_algae.location))\n\n            # Move towards algae\n            hops = utils.get_optimal_next_hops(self.ctx.get_location(), nearest_algae.location)\n            if hops:\n                return move(hops[0])\n\n        return None\n</code></pre>"},{"location":"api_reference/game_api/","title":"GameAPI","text":"<p>Accessible in <code>spawn_policy(api)</code>.</p>"},{"location":"api_reference/game_api/#global-information","title":"Global Information","text":"<ul> <li><code>get_tick()</code>: Returns the current tick of the game (int).</li> <li><code>get_scraps()</code>: Returns the total scraps available to you (int).</li> <li><code>get_my_bots()</code>: Returns a list of all bots owned by you (<code>list[Bot]</code>).</li> <li><code>view</code>: The <code>PlayerView</code> object holding the complete game state. See Player View &amp; Perception.</li> </ul>"},{"location":"api_reference/game_api/#sensing","title":"Sensing","text":"<ul> <li><code>visible_enemies()</code>: Returns a list of all visible enemy bots (<code>list[EnemyBot]</code>).</li> <li><code>visible_scraps()</code>: Returns a list of all visible scrap entities (<code>list[Scrap]</code>).</li> <li><code>banks()</code>: Returns a list of visible banks (<code>list[Bank]</code>).</li> <li><code>energypads()</code>: Returns a list of visible energy pads (<code>list[EnergyPad]</code>).</li> <li><code>visible_walls()</code>: Returns a list of visible walls (<code>list[Point]</code>).</li> <li><code>visible_algae()</code>: Returns a list of visible algae (<code>list[Algae]</code>).</li> </ul>"},{"location":"api_reference/game_api/#spawning","title":"Spawning","text":"<ul> <li><code>can_spawn(abilities)</code>: Returns <code>True</code> if you have enough scraps to spawn a bot with the given abilities (<code>list[Ability]</code>).</li> </ul>"},{"location":"api_reference/game_api/#example","title":"Example","text":"<pre><code>from seamaster import GameAPI, BotController\n\n# Access in spawn_policy\ndef spawn_policy(api: GameAPI):\n    # Check global state\n    if api.get_scraps() &gt;= 20:\n        return [{\"location\": 0, \"strategy\": ...}]\n\n# Access inside a Bot using self.ctx.api\nclass MyBot(BotController):\n    def act(self):\n        # You can access the API directly if needed\n        all_banks: list[Bank] = self.ctx.api.banks()\n</code></pre>"},{"location":"api_reference/utilities/","title":"Utilities (<code>seamaster.utils</code>)","text":"<p>Collection of helper functions for geometry and pathfinding.</p> <ul> <li><code>manhattan_distance(p1, p2)</code>: Returns the Manhattan distance between two <code>Point</code>s (int).</li> <li><code>next_point(p, direction)</code>: Returns the next <code>Point</code> in a given <code>Direction</code>, or <code>None</code> if out of bounds.</li> <li><code>direction_from_point(p1, p2)</code>: Returns the primary <code>Direction</code> from <code>p1</code> to <code>p2</code>.</li> <li><code>get_optimal_next_hops(start, end)</code>: Returns a list of <code>Direction</code>s representing optimal moves from <code>start</code> to <code>end</code>.</li> <li><code>get_shortest_distance_between_points(start, end)</code>: Returns the shortest path distance (int) between two points using precomputed paths.</li> </ul>"},{"location":"api_reference/utilities/#example","title":"Example","text":"<pre><code>from seamaster.utils import manhattan_distance, get_optimal_next_hops\nfrom seamaster.constants import Direction\n\n# Calculate distance\ndist = manhattan_distance(p1, p2)\n\n# Get path directions\nhops: list[Direction] = get_optimal_next_hops(start_pos, end_pos)\nif hops:\n    next_move = hops[0]\n</code></pre>"},{"location":"arena/board/","title":"The Board","text":"<p>The game is played on a fixed 20x20 grid.</p>"},{"location":"arena/board/#coordinates","title":"Coordinates","text":"<p>The board uses a standard Cartesian coordinate system where (0,0) is the corner.</p> <ul> <li>X-axis: 0 to 19.</li> <li>Y-axis: 0 to 19.</li> </ul> <p>Note</p> <p><code>X</code> is the horizontal axis. <code>Y</code> is the vertical axis.</p>"},{"location":"arena/board/#walls","title":"Walls","text":"<p>The board contains static walls that block movement. Bots cannot move into or through walls.</p> <ul> <li>Symmetry: The wall layout is symmetric and deterministic. It is the same for every match (unless the map generation code changes).</li> <li>Coordinates: You can find the exact list of wall coordinates in your <code>PlayerView</code> object under <code>permanent_entities.walls</code>.</li> <li>Reference: See Player View &amp; Perception for data structure details.</li> </ul>"},{"location":"arena/board/#spawning-zones","title":"Spawning Zones","text":"<p>Players spawn on opposite sides of the board.</p> <ul> <li>Player 1 (You): Spawns on the edge where <code>y=0</code>.</li> <li>Player 2 (Opponent): Spawns on the edge where <code>y=19</code>.</li> </ul> <p>Coordinate Flipping</p> <p>To ensure fairness and simplicity, the engine flips the x-coordinates for Player 2. This means both players can write logic assuming they are on the \"left\" (or \"right\", depending on perspective), but their actual positions on the grid are mirrored.</p> <p>When you spawn a bot using <code>spawn(location=x)</code>, it appears at coordinate <code>(x, 0)</code> for Player 1, or <code>(x, 19)</code> for Player 2. Valid <code>location</code> values are <code>0</code> to <code>19</code>.</p>"},{"location":"arena/bots/","title":"The Bot","text":"<p>The Bot is the fundamental unit of Seawars. You do not control a single character; you control a swarm.</p>"},{"location":"arena/bots/#the-bot-object","title":"The Bot Object","text":"<p><code>Bot</code> objects are the core data structure representing your units.</p> <pre><code>class Bot:\n    id: int\n    location: Point\n    energy: float\n    scraps: int\n    abilities: List[Ability]\n    algae_held: int\n    traversal_cost: float\n    status: str\n</code></pre>"},{"location":"arena/bots/#attributes","title":"Attributes","text":"<ul> <li>id: Unique identifier for the bot within the match. Use this to track specific units across ticks.</li> <li>location: Current coordinates (<code>x</code>, <code>y</code>) on the board.</li> </ul> <p>Note</p> <p>The location of the bot is a Point object, which points to its abosulte position in the board. Refer to Board Coordinates for more details.</p> <ul> <li>energy: Current energy level. Max 50. Dropping to 0 prevents actions.</li> <li>scraps: The amount of scraps this bot is \"worth\" (the cost to spawn it). This value is used for scoring/rewards when destroyed.</li> <li>abilities: List of abilities equipped on this bot (e.g., <code>[\"HARVEST\", \"SPEEDBOOST\"]</code>).</li> <li>algae_held: Current number of algae in inventory. Max 5.</li> <li>traversal_cost: The energy cost for this bot to move 1 tile. Calculated based on equipped abilities.</li> <li>status: Current state of the bot (e.g., \"ACTIVE\", \"DEAD\").</li> </ul>"},{"location":"arena/bots/#construction-cost","title":"Construction &amp; Cost","text":"<p>Bots are designed as modular units. You start with an Empty Shell (chassis) and equip it with Abilities.</p> <ul> <li>Construction Cost: The total cost to spawn a bot.</li> <li>Formula: <code>Total Cost = Base Cost + Sum(Ability Costs)</code></li> </ul> <p>Currently, the Base Cost for the shell is 0 scraps, meaning you only pay for the abilities you choose. However, a functional bot typically requires at least Movement, enforcing a practical minimum cost (e.g., 10 scraps).</p>"},{"location":"arena/bots/#the-life-cycle","title":"The Life Cycle","text":"<ol> <li>Spawn: You request a spawn at your designated spawn zone. Costs scraps.</li> <li>Act: Every tick, your code issues a command (Move, Harvest, etc.).</li> <li>Refill: When bots run out of energy, they are unable to execute any actions (movement or abilities) that require energy. To recharge energy before it runs out, bots must visit an Energy Pad.</li> <li>Death: Bots die if:<ul> <li>They execute <code>SelfDestruct</code>.</li> <li>They are hit by a <code>SelfDestruct</code> explosion.</li> <li>They harvest Poisonous Algae.</li> </ul> </li> </ol>"},{"location":"arena/entities/","title":"Game Entities","text":"<p>Beyond walls and empty space, the grid contains several interactive entities.</p>"},{"location":"arena/entities/#algae-resources","title":"Algae (Resources)","text":"<p>Algae is the primary resource in Seawars. It spawns randomly at the start of the match and does not regrow.</p> <ul> <li>Abundance: Roughly 15% of the board tiles contain algae (~60 total).</li> <li>Visibility: You know the location of every algae tile on the board from the start (<code>PlayerView.visible_entities.algae</code>).</li> <li>Poison Status: Roughly 5% of algae is Poisonous. This status is Hidden (\"UNKNOWN\") until scouted.</li> <li>Normal Algae: Can be harvested for resource points.</li> <li>Poisonous Algae: Kills any bot that attempts to harvest it.</li> </ul> <p>Warning</p> <p>Scout before you harvest! While you can see where the algae is, indiscriminately harvesting \"UNKNOWN\" algae is a risk.</p> Checking Algae Safety <pre><code>from seamaster.constants import AlgaeType\n\ndef act(self):\n    # Access list of all algae\n    all_algae = self.ctx.api.visible_algae()\n\n    for algae in all_algae:\n        if algae.is_poison == AlgaeType.FALSE:\n             print(f\"Safe algae at {algae.location}!\")\n</code></pre>"},{"location":"arena/entities/#banks","title":"Banks","text":"<p>Banks are locations where collected algae must be deposited to score points.</p> <ul> <li>Functionality: Bots with the harvest ability can deposit algae they are carrying into a bank.</li> <li>Deposit Range: A bot must be within 2 units of a bank to deposit.</li> <li>Deposit Time: Depositing takes 50 ticks, during which the bank is susceptible to being lockpicked by a bot with the lockpick ability.</li> </ul> <p>Note</p> <p>A bot with the lockpick ability can steal the algae which is being deposited into the bank by the enemy player. This action takes 10 ticks (continuously, if the lockpick is interrupted in the middle, it needs to start again for 10 ticks).</p> <ul> <li>Ownership: There are two banks in each player's half of the map. The two banks closest to you are owned by you, and the two banks closest to your opponent are owned by the opponent. You can only deposit algae in a bank you own. Conversely, you can only lockpick an opponent's bank.</li> <li>Coordinates: You can find the exact list of bank coordinates in your <code>PlayerView</code> object under <code>permanent_entities.banks</code>.</li> <li>Reference: See Player View &amp; Perception for data structure details.</li> </ul>"},{"location":"arena/entities/#energy-pads","title":"Energy Pads","text":"<p>Energy pads are special locations that refill a bot's energy.</p> <ul> <li>Functionality: When a bot stands on an energy pad, its energy is restored to the spawn energy level.</li> <li>Cooldown: After use, an energy pad goes on cooldown for 25 ticks and cannot be used again until the cooldown expires.</li> <li>Coordinates: You can find the exact list of energy pad coordinates in your <code>PlayerView</code> object under <code>permanent_entities.energypads</code>.</li> <li>Reference: See Player View &amp; Perception for data structure details.</li> </ul> Checking Energy Pad Availability <pre><code>def act(self):\n    pads = self.ctx.get_energy_pads()\n\n    for pad in pads:\n        if pad.available:\n            print(f\"Pad at {pad.location} is ready!\")\n        else:\n            print(f\"Pad at {pad.location} ready in {pad.ticks_left} ticks.\")\n</code></pre>"},{"location":"arena/entities/#scraps-currency","title":"Scraps (Currency)","text":"<p>Scraps are the currency used to construct new bots. You pay for the bot's chassis and its equipped abilities.</p> <ul> <li>Global Pool: All scraps belong to you (the player), not individual bots.</li> <li>Starting Scraps: 100 per player.</li> <li>Passive Income: +1 scrap per tick.</li> <li>Salvage: When a bot dies, it drops 50% of its total cost on the tile where it fell.</li> </ul> <p>Note</p> <p>Bots with the Harvest ability can collect these dropped scraps by moving onto the tile. Collected scraps are immediately added to your global pool.</p>"},{"location":"glossary/glossary/","title":"Glossary","text":""},{"location":"glossary/glossary/#fundamentals","title":"Fundamentals","text":"<ul> <li>Tick: A single discrete time unit in the game. The game lasts for a maximum of 500 Ticks.</li> <li>Round: Often used interchangeably with Tick, but technically refers to the full process of both players submitting moves and the engine resolving them.</li> <li>Arena / Board: The game world. A 20x20 grid where all gameplay takes place.</li> <li>Coordinates: The grid system used to locate entities, ranging from <code>(0,0)</code> to <code>(19,19)</code>.</li> <li>SeaMaster: The game engine that resolves moves and maintains the state.</li> <li>CodeRunner: The system that executes player code safely involved in the timeout logic.</li> </ul>"},{"location":"glossary/glossary/#entities-resources","title":"Entities &amp; Resources","text":"<ul> <li>Entity: Any object on the board, including Bots, Algae, Banks, and Energy Pads.</li> <li>Bot: The primary unit controlled by players. Bots have Energy, Scraps, and can hold Algae.</li> <li>Scrap: The resource used to spawn new bots. Scraps are finite and managed at the player level.</li> <li>Energy: The fuel for bots. Moving and performing abilities consumes Energy.</li> <li>Algae: The primary scoring resource. Harvested from the board and deposited at Banks.</li> <li>Bank: A structure where Algae is deposited to earn points.</li> <li>Energy Pad: A structure that instantly replenishes a bot's Energy to full.</li> </ul>"},{"location":"glossary/glossary/#abilities-actions","title":"Abilities &amp; Actions","text":"<ul> <li>Loadout: The specific set of abilities a bot is spawned with.</li> <li>Abilities: Special skills assigned to bots (e.g., Speed Boost, Shield, Poison).</li> <li>Context (<code>ctx</code>): The data object containing current game state visible to a bot.</li> <li>Scout: Reveals hidden information like Poison within a 4-tile radius.</li> <li>Lockpick: Steals deposits from enemy banks.</li> <li>Manhattan Distance: The distance metric used ( |x1-x2| + |y1-y2| ).</li> </ul>"},{"location":"mechanics/actions_and_abilities/","title":"Actions &amp; Abilities","text":"<p>Every tick, each of your bots can perform one action.</p>"},{"location":"mechanics/actions_and_abilities/#energy-scrap-costs","title":"Energy &amp; Scrap Costs","text":""},{"location":"mechanics/actions_and_abilities/#energy-costs","title":"Energy Costs","text":"<p>Bots consume energy for movement and actions.</p> <ul> <li>Base Movement Cost: 2 HP per move.</li> </ul> Ability Traversal Modifier (per move) Action Cost (on use) Harvest +0 1 Scout +1.5 0 Self-Destruct +0.5 0 Speed Boost +1 0 Poison +0.5 2 Lockpick +1.5 0 Shield +0.25 0 Deposit +0 1"},{"location":"mechanics/actions_and_abilities/#scrap-costs","title":"Scrap Costs","text":"<p>Base cost to spawn a bot is 10 Scraps. Adding abilities increases the cost:</p> Ability Scrap Cost Harvest 8 Scout 8 Self-Destruct 6 Lockpick 6 Speed Boost 8 Poison 7 Shield 7"},{"location":"mechanics/actions_and_abilities/#actions","title":"Actions","text":"<p>Your bots can perform the following physical actions on the board:</p>"},{"location":"mechanics/actions_and_abilities/#move","title":"Move","text":"<p>Bots can move in cardinal directions: <code>NORTH</code>, <code>SOUTH</code>, <code>EAST</code>, <code>WEST</code>.</p> <ul> <li>Cost: 2 Energy per move.</li> <li>Speed: 1 tile per tick.</li> <li>Associated Ability: <code>Speed Boost</code> (Doubles speed, reduces energy cost).</li> </ul> Movement Example <pre><code>from seamaster.constants import Direction\nfrom seamaster.translate import move\n\ndef act(self):\n    # Move North\n    return move(Direction.NORTH)\n</code></pre>"},{"location":"mechanics/actions_and_abilities/#harvest","title":"Harvest","text":"<ul> <li>Action: <code>HARVEST</code></li> <li>Requirement: Must be on top of an Algae tile.</li> <li>Effect: Removes algae from board, adds +1 to inventory.</li> <li>Energy Cost: 1 Energy.</li> <li>Associated Ability: <code>Harvest</code> (Required to perform action).</li> <li>Warning: Harvesting Poisonous Algae kills the bot instantly.</li> <li>Move + Harvest: You can specify a <code>direction</code> to move and harvest in the same tick. The bot moves one step in the <code>direction</code> and attempts to harvest at the new location.</li> </ul> <p>Python Library Update</p> <p>The Python library is currently being updated to support the optional <code>direction</code> parameter for <code>harvest</code>, <code>lockpick</code>, and <code>poison</code>.</p> Harvesting Example <pre><code>from seamaster.constants import Direction\nfrom seamaster.translate import harvest\n\ndef act(self):\n    # Move + Harvest (Adjacent Tile)\n    return harvest(Direction.NORTH)\n</code></pre>"},{"location":"mechanics/actions_and_abilities/#deposit","title":"Deposit","text":"<ul> <li>Action: <code>DEPOSIT</code></li> <li>Requirement: Must be within range of a Bank you own.</li> <li>Effect: Starts a deposit timer (100 ticks). If effective, converts inventory to score.</li> <li>Vulnerability: While depositing, you are immovable and vulnerable to theft.</li> <li>Associated Ability: <code>Harvest</code> (implied, as you need to harvest to deposit).</li> </ul> Banking Example <pre><code>from seamaster.translate import deposit\n\ndef act(self):\n    # If we are at a bank we own, deposit\n    if self.ctx.is_at_bank():\n        return deposit(None)\n</code></pre>"},{"location":"mechanics/actions_and_abilities/#self-destruct","title":"Self-Destruct","text":"<ul> <li>Action: <code>SELFDESTRUCT</code></li> <li>Requirement: <code>Ability.SELF_DESTRUCT</code></li> <li>Effect: The bot explodes, destroying itself and all bots (friend or foe) within a 1-tile radius (3x3 area).</li> <li>Energy Cost: 0.5 Energy.</li> <li>Associated Ability: <code>Self-Destruct</code> (Required to perform action).</li> <li>Counter: <code>Shield</code> ability.</li> </ul>"},{"location":"mechanics/actions_and_abilities/#lockpick","title":"Lockpick","text":"<ul> <li>Action: <code>LOCKPICK</code></li> <li>Requirement: Must be adjacent to a Bank where an enemy is depositing.</li> <li>Effect: Steals the deposit.</li> <li>Risk: The Lockpick bot dies after the theft is complete (Suicide mission).</li> <li>Move + Lockpick: You can initiate a lockpick on a bank from an adjacent tile. The bot moves adjacent to the bank and begins the lockpick in the same tick.</li> <li>Associated Ability: <code>Lockpick</code> (Required to perform action).</li> </ul> Lockpick Example <pre><code>from seamaster.translate import lockpick\nfrom seamaster.constants import Direction\n\ndef act(self):\n    # Move adjacent to bank and start lockpicking\n    return lockpick(direction=Direction.WEST)\n</code></pre>"},{"location":"mechanics/actions_and_abilities/#poison","title":"Poison","text":"<ul> <li>Action: <code>POISON</code></li> <li>Requirement: Must be on top of an Algae tile.</li> <li>Effect: Turns the algae into Poisonous Algae.</li> <li>Energy Cost: 2 Energy.</li> <li>Associated Ability: <code>Poison</code> (Required to perform action).</li> <li>Move + Poison: You can specify a <code>direction</code> to move and poison in the same tick.</li> </ul> Poison Example <pre><code>from seamaster.constants import Direction\nfrom seamaster.translate import poison\n\ndef act(self):\n    # Move South and poison the algae there\n    return poison(Direction.SOUTH)\n</code></pre>"},{"location":"mechanics/actions_and_abilities/#abilities","title":"Abilities","text":"<p>Abilities are special upgrades or traits that your bots can possess:</p>"},{"location":"mechanics/actions_and_abilities/#harvest_1","title":"Harvest","text":"<ul> <li>Description: Allows the bot to harvest algae and deposit it at banks.</li> <li>Note: Essential for scoring.</li> </ul>"},{"location":"mechanics/actions_and_abilities/#scout","title":"Scout","text":"<ul> <li>Description: Reveals the <code>is_poison</code> status of all algae within a 4-tile radius.</li> <li>Note: Without this ability (or proximity), algae status remains \"UNKNOWN\". Only bots with the Scout ability can distinguish Poisonous Algae from Safe Algae. Global vision gives you coordinates, but Scouting gives you safety.</li> </ul>"},{"location":"mechanics/actions_and_abilities/#self-destruct_1","title":"Self-Destruct","text":"<ul> <li>Description: Allows the bot to self-destruct, dealing area damage.</li> </ul>"},{"location":"mechanics/actions_and_abilities/#lockpick_1","title":"Lockpick","text":"<ul> <li>Description: Allows the bot to steal deposits from enemy banks.</li> </ul>"},{"location":"mechanics/actions_and_abilities/#speed-boost","title":"Speed Boost","text":"<ul> <li>Description: Increases movement speed and efficiency.</li> <li>Effect: Movement speed doubled (2 tiles per tick).</li> <li>Energy Cost: 1 Energy per move (More efficient!).</li> </ul>"},{"location":"mechanics/actions_and_abilities/#poison_1","title":"Poison","text":"<ul> <li>Description: Allows the bot to poison algae tiles, creating traps for enemy bots.</li> </ul>"},{"location":"mechanics/actions_and_abilities/#shield","title":"Shield","text":"<ul> <li>Description: Passive protection against damage.</li> <li>Effect: If hit by a <code>SelfDestruct</code> or other damage, the shield breaks instead of the bot dying. The bot loses the Shield ability but survives.</li> <li>Side Effect: Shield increases movement energy cost by 0.25.</li> </ul>"},{"location":"mechanics/perception/","title":"Player View &amp; Perception","text":"<p>Unlike many other strategy games, Seawars provides Global Vision. You have access to the entire game state through the <code>PlayerView</code> object, with one specific exception (Algae Poison Status).</p>"},{"location":"mechanics/perception/#the-playerview-object","title":"The PlayerView Object","text":"<p>Your bot logic receives a <code>PlayerView</code> object each tick. This object serves as the single source of truth for the game state.</p> Accessing PlayerView <pre><code>def act(self):\n    # Access the view via self.ctx.api.view\n    playerview = self.ctx.api.view\n\n    print(f\"Current Tick: {playerview.tick}\")\n    print(f\"My Scraps: {playerview.scraps}\")\n\n    # Alternatively, use the helper functions in gameAPI\n    print(f\"Current Tick: {self.ctx.api.get_tick()}\")\n    print(f\"My Scraps: {self.ctx.api.get_scraps()}\")\n</code></pre> <p>Indirect Access Preferred</p> <p>In most cases, you do not need to interact with the <code>PlayerView</code> object directly. The helper functions provided in GameAPI, BotContext, and Utilities cover almost all common use cases (finding nearest entities, pathfinding, checking global stats, etc.). Use the raw <code>playerview</code> only when you need custom filtering or data not exposed by the helper methods.</p>"},{"location":"mechanics/perception/#global-fields","title":"Global Fields","text":"<ul> <li>tick: Current game tick (0 to 500).</li> <li>scraps: Your current global currency count.</li> <li>algae: Your current score (total permanent algae secured).</li> <li>bot_id_seed: The starting ID for your next spawned bot.</li> <li>bots: A list of all your own alive bots with full status details.</li> </ul>"},{"location":"mechanics/perception/#visible-entities-enemies-scraps","title":"Visible Entities (Enemies &amp; Scraps)","text":"<p>The <code>visible_entities</code> field contains dynamic objects on the board.</p> <ul> <li>Enemies (<code>visible_entities.enemies</code>): A list of ALL enemy bots currently on the board. You know their ID, Location, Scraps held, and Abilities.</li> <li>Scraps (<code>visible_entities.scraps</code>): A list of scraps dropped on the ground from destroyed bots.</li> </ul> Filtering Enemies <pre><code>from seamaster.constants import Ability\nfrom seamaster.models import EnemyBot\n\ndef act(self):\n    enemies: list[EnemyBot] = self.ctx.api.view.visible_entities.enemies\n\n    # Find enemies carrying algae\n    rich_enemies = [e for e in enemies if e.algae_held &gt; 0]\n\n    # Find enemies with SCOUT ability\n    scouts = [e for e in enemies if Ability.SCOUT in e.abilities]\n</code></pre>"},{"location":"mechanics/perception/#permanent-entities-map-features","title":"Permanent Entities (Map Features)","text":"<p>The <code>permanent_entities</code> field contains static or semi-static map features.</p> <ul> <li>Banks: Locations of all banks.</li> <li>Energy Pads: Locations and status of energy pads.</li> <li>Walls: Locations of all wall tiles.</li> <li>Algae (<code>permanent_entities.algae</code>): A list of ALL algae resource tiles on the board.</li> </ul>"},{"location":"mechanics/perception/#structure-reference","title":"Structure Reference","text":"<p>The <code>PlayerView</code> object follows this structure:</p> <pre><code>{\n  \"tick\": \"int\",\n  \"scraps\": \"int\",\n  \"algae\": \"int\",           // Your total score\n  \"bot_id_seed\": \"int\",     // Next ID for your spawned bot\n  \"max_bots\": \"int\",\n  \"width\": \"int\",\n  \"height\": \"int\",\n\n  \"bots\": {                 // Map of Your_Bot_ID -&gt; Bot Object\n    \"id\": {\n      \"id\": \"int\",\n      \"location\": {\"x\": \"int\", \"y\": \"int\"},\n      \"energy\": \"float\",\n      \"scraps\": \"int\",\n      \"abilities\": [\"str\"], // [\"HARVEST\", \"SCOUT\", ...]\n      \"algae_held\": \"int\",\n      \"status\": \"str\"       // \"ALIVE\"\n    }\n  },\n\n  \"visible_entities\": {\n    \"enemies\": [            // List of ALL enemy bots\n      {\n        \"id\": \"int\",\n        \"location\": {\"x\": \"int\", \"y\": \"int\"},\n        \"scraps\": \"int\",\n        \"abilities\": [\"str\"]\n      }\n    ],\n    \"algae\": [              // List of ALL algae\n       {\n         \"location\": {\"x\": \"int\", \"y\": \"int\"},\n         \"is_poison\": \"str\" // \"UNKNOWN\" | \"TRUE\" | \"FALSE\"\n       }\n    ]\n  },\n\n  \"permanent_entities\": {\n     \"banks\": { \"id\": { ... } },      // Map of Bank_ID -&gt; Bank Object\n     \"energy_pads\": { \"id\": { ... } }, // Map of Pad_ID -&gt; Pad Object\n     \"walls\": [{\"x\": \"int\", \"y\": \"int\"}]\n  }\n}\n</code></pre>"},{"location":"mechanics/perception/#the-poison-mechanic-hidden-info","title":"The Poison Mechanic (Hidden Info)","text":"<p>While you know the location of every algae tile from the start, you do not inherently know if it is safe or poisonous.</p>"},{"location":"mechanics/perception/#algae-properties","title":"Algae Properties","text":"<p>Each Algae object in <code>permanent_entities.algae</code> has an <code>is_poison</code> field with three possible values (defined in <code>AlgaeType</code>): 1.  \"UNKNOWN\": The default state. You know algae is there, but not if it's safe. 2.  \"TRUE\": Confirmed Poisonous. 3.  \"FALSE\": Confirmed Safe.</p>"},{"location":"mechanics/perception/#revealing-poison-scouting","title":"Revealing Poison (Scouting)","text":"<p>To reveal the <code>is_poison</code> status, you must use the Scout ability.</p> <ul> <li>Ability: <code>SCOUT</code></li> <li>Range: 4 tiles (Manhattan Distance).</li> <li>Effect: Any algae within 4 tiles of a bot with the <code>SCOUT</code> ability will have its <code>is_poison</code> field updated to \"TRUE\" or \"FALSE\" in your <code>PlayerView</code>.</li> </ul> <p>Important</p> <p>This is the only \"Hidden Information\" in the game. Enemy movement and map layout are fully visible.</p> Safe Harvesting Logic <pre><code>from seamaster.constants import AlgaeType\n\ndef is_safe_to_harvest(self, algae):\n    # Only harvest if CONFIRMED safe\n    if algae.is_poison == AlgaeType.FALSE:\n        return True\n    return False\n\ndef act(self):\n    # Example: iterate visible algae and check safety\n    for algae in self.ctx.api.view.visible_entities.algae:\n        if self.is_safe_to_harvest(algae):\n            # Go harvest it...\n            pass\n</code></pre>"},{"location":"mechanics/resolution/","title":"Resolution Rules","text":"<p>The game engine resolves actions in a specific order. Understanding this is key to winning \"tie-breaks\".</p>"},{"location":"mechanics/resolution/#turn-order","title":"Turn Order","text":"<p>The Game Loop processes a tick in this order:</p> <ol> <li>Spawning: New bots are created.<ul> <li>If a spawn location is occupied, the spawn fails.</li> </ul> </li> <li>Actions: Existing bots execute their commands.<ul> <li>Iterates through all bots.</li> </ul> </li> <li>Entity Updates: Banks and Energy Pads update their timers.</li> <li>Win Check: Victory conditions are checked.</li> </ol>"},{"location":"mechanics/resolution/#action-resolution","title":"Action Resolution","text":"<p>The engine resolves actions based on a strict priority system. When multiple bots attempt actions in the same tick, they are processed in the following order:</p> Info <p>Each bot can only perform one move per tick. Some actions, such as <code>HARVEST</code> and <code>LOCKPICK</code>, have an option where the bot can move to a location and perform the action, essentially allowing the bot to perform two 'actions' (move and harvest/lockpick) in the same tick.</p>"},{"location":"mechanics/resolution/#1-priority-tiers","title":"1. Priority Tiers","text":"<p>Actions with higher priority numbers are resolved first.</p> Priority Action 6 <code>SELFDESTRUCT</code> 5 <code>HARVEST</code> 4 <code>POISON</code> 3 <code>DEPOSIT</code> 2 <code>LOCKPICK</code> 1 <code>MOVE</code>"},{"location":"mechanics/resolution/#2-tie-breakers","title":"2. Tie-Breakers","text":"<p>If multiple bots want to perform actions with the same priority (e.g., two bots trying to Move into the same tile), the engine resolves the conflict using these tie-breakers, in order:</p> <ol> <li>Energy: Bot with Higher Energy goes first.</li> <li>Age: Bot that was Spawned Earlier (lower Bot ID) goes first.</li> <li>Random: If Energy and Age are identical, it is determined randomly.</li> </ol>"},{"location":"mechanics/resolution/#collision","title":"Collision","text":"<ul> <li>Bots cannot share a tile.</li> <li>Bots cannot move through each other.</li> <li>Bots cannot swap places directly in one tick (head-on collision).</li> </ul>"},{"location":"mechanics/resolution/#timeout-errors","title":"Timeout &amp; Errors","text":"<ul> <li>Time Limit: Your code has a limited time to respond (e.g., 20ms - 100ms per tick).</li> <li>Timeout: If you exceed the limit, your turn is skipped.</li> <li>Crash: If your code throws an exception, your turn is skipped.</li> <li>Disqualification: Too many consecutive errors/timeouts will disqualify you from the match.</li> </ul>"},{"location":"mechanics/win_conditions/","title":"Win Conditions","text":"<p>There are three ways to end a match.</p>"},{"location":"mechanics/win_conditions/#1-absolute-dominance","title":"1. Absolute Dominance","text":"<p>If at any point a player has permanently deposited &gt; 50% of the total algae on the map: *   Result: Immediate Victory.</p>"},{"location":"mechanics/win_conditions/#2-time-limit","title":"2. Time Limit","text":"<p>If the game reaches 500 Ticks:</p> <ul> <li>The game ends.</li> <li>Winner: Information based on Permanent Algae count.<ul> <li>Player with most deposited algae wins.</li> <li>If tied, it interprets as a Draw.</li> </ul> </li> </ul>"},{"location":"mechanics/win_conditions/#3-timeout","title":"3. Timeout","text":"<p>The Code Runner maintains a Timeout Score for each bot.</p> <ul> <li>Timeout Event: If a bot's code times out or crashes, its Timeout Score increases.</li> <li>Normal Execution: If the bot executes successfully, its Timeout Score decreases (or stays at 0).</li> <li>Disqualification: If the Timeout Score reaches 5, the match ends immediately, and that player loses.</li> </ul>"},{"location":"sdk/debugging/","title":"Debugging &amp; Logs","text":""},{"location":"sdk/debugging/#runtime-logs","title":"Runtime Logs","text":"<p>The game engine captures standard output (<code>stdout</code>) and standard error (<code>stderr</code>).</p> <ul> <li>Stdout: Used for game communication (do not print random text here, it might break the protocol).</li> <li>Stderr: Use <code>sys.stderr</code> for debugging information.</li> </ul> <pre><code>import sys\nprint(\"DEBUG: My bot is stuck!\", file=sys.stderr)\n</code></pre>"},{"location":"sdk/debugging/#common-errors","title":"Common Errors","text":"<ol> <li>Timeout: Your <code>act()</code> function took too long. Optimize your code.</li> <li>Memory Limit: You allocated too much memory. Avoid large global lists.</li> <li>Invalid Move: You tried to walk into a wall or another bot.</li> </ol>"},{"location":"sdk/debugging/#the-sandwich-strategy","title":"The Sandwich Strategy","text":"<p>If your bot is behaving strangely, check if it's dead. Dead bots cannot act. Check if you have Energy. Low energy bots cannot move.</p>"},{"location":"sdk/first_bot/","title":"Build Your First Bot (Custom Logic)","text":"<p>In this guide, we will write a complete bot from scratch. While the <code>seamaster</code> library provides powerful Templates (see Writing Your Bot), writing your own logic gives you maximum control.</p> <p>We will build a Harvester Bot that autonomousy manages its energy, harvests algae, and deposits it at a bank.</p> <p>Copy-Paste Friendly</p> <p>The code blocks in this guide have aligned line numbers. You can copy and paste them sequentially into your file to build the complete bot.</p>"},{"location":"sdk/first_bot/#1-imports-and-setup","title":"1. Imports and Setup","text":"<p>Create a new file <code>my_first_bot.py</code>. We start by importing the necessary components from the library.</p> <pre><code>from seamaster import GameAPI\nfrom seamaster.botbase import BotController\nfrom seamaster.constants import Ability, ABILITY_COSTS, SCRAP_COSTS, Direction\nfrom seamaster.models import EnergyPad, Bank\nfrom seamaster.translate import move, harvest, deposit\nfrom seamaster import utils\nimport random\n</code></pre>"},{"location":"sdk/first_bot/#2-defining-the-bot-class","title":"2. Defining the Bot Class","text":"<p>We inherit from <code>BotController</code> and define our capabilities.</p> <pre><code>class harvester_bot(BotController):\n    ABILITIES = [Ability.HARVEST]  # (1)\n    ability_scrap_cost = SCRAP_COSTS[Ability.HARVEST]\n    ability_energy_cost = ABILITY_COSTS[Ability.HARVEST] \n\n    def __init__(self, ctx):\n        super().__init__(ctx)\n</code></pre> <ol> <li>Capabilities: We declare that this bot needs the <code>HARVEST</code> ability. The game engine uses this to calculate spawn costs.</li> </ol>"},{"location":"sdk/first_bot/#3-the-brain-act","title":"3. The Brain (<code>act</code>)","text":"<p>The <code>act()</code> method is the heart of your bot. It runs every tick. Our logic follows a simple priority system:</p> <ol> <li>Survival: If energy is low, find a charger.</li> <li>Banking: If carrying any algae, go deposit immediately.</li> <li>Work: Otherwise, find algae and harvest.</li> </ol> <pre><code>    def act(self):\n        # 1. Survival: If energy is below 50%, head to recharge ports\n        current_energy = self.ctx.get_energy()\n        if current_energy &lt; 25:\n            nearest_energy_pad : EnergyPad = self.ctx.get_nearest_energy_pad()\n            # Calculate path to energy pad\n            move_priorities = utils.get_optimal_next_hops(self.ctx.get_location(), nearest_energy_pad.location) # (1)\n            if move_priorities:\n                return move(move_priorities[0]) # (2)\n\n        # 2. Banking: If I'm carrying algae, deposit it\n        if self.ctx.get_algae_held() &gt; 0:\n            # Find banks owned by me\n            banks: list[Bank] = {\n                bank for bank in self.ctx.api.banks() \n                    if bank.is_bank_owner == True\n            }\n            if banks:\n                # Find nearest bank\n                nearest_bank: Bank = min(banks, key=lambda bank: utils.manhattan_distance(self.ctx.get_location(), bank.location))\n                dist_to_bank = utils.get_shortest_distance_between_points(self.ctx.get_location(), nearest_bank.location)\n\n                # If adjacent, deposit. Else, move towards it.\n                if not dist_to_bank or dist_to_bank &lt; 2:\n                    return deposit(utils.direction_from_point(self.ctx.get_location(), nearest_bank.location)) # (3)\n                else:   \n                    move_priorities = utils.get_optimal_next_hops(self.ctx.get_location(), nearest_bank.location)\n                    if move_priorities:\n                        return move(move_priorities[0])\n\n        # 3. Work: Find and harvest algae\n        nearest_algae = self.ctx.get_nearest_algae()\n        dist_to_algae = utils.manhattan_distance(self.ctx.get_location(), nearest_algae.location)\n\n        if dist_to_algae &gt;= 2:\n            alg_move_priorities = utils.get_optimal_next_hops(self.ctx.get_location(), nearest_algae.location)\n            if alg_move_priorities:\n                return move(alg_move_priorities[0])\n        elif dist_to_algae &lt; 2 and dist_to_algae &gt; 0:\n            return harvest(utils.direction_from_point(self.ctx.get_location(), nearest_algae.location)) # (4)\n        else: \n            return harvest(None)\n</code></pre> <ol> <li>Pathfinding: <code>utils.get_optimal_next_hops</code> helps navigate around obstacles.</li> <li>Action: We execute the move command.</li> <li>Deposit: Uses <code>direction_from_point</code> to target the specific bank tile.</li> <li>Harvest: Targeted harvest ensures we grab the specific algae we want.</li> </ol>"},{"location":"sdk/first_bot/#4-the-spawn-policy","title":"4. The Spawn Policy","text":"<p>Finally, we tell the engine to create our bots.</p> <pre><code>def spawn_policy(gameAPI: GameAPI):\n    # Spawn a harvester in every tick\n    spawn_rules = [] \n\n    # spawn a harvester at a random X location\n    spawn_x = random.randint(0, gameAPI.view.width-1)\n    spawn_rules.append(harvester_bot.spawn(spawn_x)) # (1)\n    return spawn_rules\n</code></pre> <ol> <li>Spawn: We invoke the <code>spawn</code> class method on our custom bot class.</li> </ol>"},{"location":"sdk/first_bot/#next-steps","title":"Next Steps","text":"<p>Congratulations! You've written a custom bot from scratch. </p> <p>To go further:</p> <ul> <li>Explore Writing Your Bot for detailed API documentation.</li> <li>Learn about Collision Resolution in Resolution Rules.</li> </ul>"},{"location":"sdk/setup/","title":"SDK Setup","text":"<p>To play Seawars, you need to write a Python script that uses the <code>seamaster</code> library.</p> <p>Single File Submission</p> <p>Your entire bot submission must be contained in a single Python file. This file will be copied and pasted directly into the code editor on the battle page.</p>"},{"location":"sdk/setup/#local-development-setup","title":"Local Development Setup","text":"<p>While the game provides an online editor, we highly recommend setting up a local development environment for a better coding experience (autocomplete, linting, etc.).</p>"},{"location":"sdk/setup/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.10+: Ensure Python is installed on your system. You can verify this by running <code>python --version</code> or <code>python3 --version</code> in your terminal.</li> </ul>"},{"location":"sdk/setup/#setting-up-a-virtual-environment-vs-code","title":"Setting Up a Virtual Environment (VS Code)","text":"<p>Visual Studio Code (VS Code) is the recommended editor. Follow these steps to set up your environment:</p> <ol> <li>Open your project folder in VS Code.</li> <li>Open the Command Palette (<code>Ctrl+Shift+P</code> used or <code>Cmd+Shift+P</code> on Mac).</li> <li>Type Python: Create Environment and select it.</li> <li>Choose Venv.</li> <li>Select your Python 3.10+ interpreter.</li> <li>VS Code will create a <code>.venv</code> folder and automatically activate it for your terminal.</li> </ol> <p>If you work from the command line, activate the environment manually:</p> <pre><code>source .venv/bin/activate\n</code></pre>"},{"location":"sdk/setup/#installing-the-library","title":"Installing the Library","text":"<p>Once your environment is active, install the <code>seamaster</code> library using pip:</p> <pre><code>pip install seamaster\n</code></pre> <p>You are now ready to start coding! The library provides all the necessary classes and types for building your bot.</p>"},{"location":"sdk/setup/#next-steps","title":"Next Steps","text":"<p>Now that your environment is set up, verify your installation by writing your first bot.</p> <p>Writing Your Bot</p>"},{"location":"sdk/writing_bots/","title":"Writing Your Bot","text":"<p>A bot consists of two parts: the Brain (Logic) and the Birth (Spawn Policy).</p>"},{"location":"sdk/writing_bots/#1-the-brain-botcontroller","title":"1. The Brain (<code>BotController</code>)","text":"<p>You define a class that inherits from <code>BotController</code>. The <code>act()</code> method is called every tick.</p> <p>You can either write your own bot logic from scratch or utilize one of the pre-built templates available in <code>seamaster.templates</code>.</p> <p>Work in Progress</p> <p>The <code>Lurker</code> and <code>Saboteur</code> templates are currently under development and are not stable for use.</p> <pre><code>from seamaster.botbase import BotController\nfrom seamaster.constants import Ability, Direction\nfrom seamaster.translate import move\n\nclass MyHarvester(BotController):\n    # Define abilities this bot needs\n    ABILITIES = [Ability.HARVEST]\n\n    def act(self):\n        # 1. Get info\n        current_loc = self.ctx.get_location()\n\n        # 2. Make decision\n        if self.ctx.sense_algae(radius=1):\n            return move(Direction.NORTH) # Or harvest command\n\n        # 3. Return action\n        return move(Direction.SOUTH)\n</code></pre>"},{"location":"sdk/writing_bots/#2-the-birth-spawn_policy","title":"2. The Birth (<code>spawn_policy</code>)","text":"<p>You must tell the engine when and where to spawn bots in each tick.</p> <pre><code>def spawn_policy(api):\n    spawn_list = []\n    tick = api.get_tick()\n\n    # Simple logic: Spawn a harvester every 10 ticks\n    if tick % 10 == 0:\n        spawn_list.append(\n            MyHarvester.spawn(location=0) # Location is relative offset in spawn zone\n        )\n\n    return spawn_list\n</code></pre>"},{"location":"sdk/writing_bots/#state-management","title":"State Management","text":"<p>You can store state in your bot class <code>__init__</code>.</p> <pre><code>class Patroller(BotController):\n    def __init__(self, ctx):\n        super().__init__(ctx)\n        self.direction = Direction.NORTH\n\n    def act(self):\n        # Use and update self.direction\n        pass\n</code></pre>"}]}